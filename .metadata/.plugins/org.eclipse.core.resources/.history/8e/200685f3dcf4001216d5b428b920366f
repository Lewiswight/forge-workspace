# http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/

# Optional. You will see this name in eg. 'ps' or 'top' command

# Port where we'll run the websocket server

# websocket and http servers

###
Global variables
###

# latest 100 messages

# list of currently connected clients (users)

###
Helper function for escaping input strings
###


respond = (req, res, next) ->
  keys = []
  for key of clientDict
  	console.log key
  res.send "hello " + clientDict[req.params.name]
restify = require("restify")
server = restify.createServer()
server.get "/hello/:name", respond
server.head "/hello/:name", respond
server.listen 8080, ->
  console.log "%s listening at %s", server.name, server.url




process.title = "node-chat"
webSocketsServerPort = 1337
webSocketServer = require("websocket").server
http = require("http")
history = []
clients = []
clientDict = new Object 
# Array with some colors
colors = ["red", "green", "blue", "magenta", "purple", "plum", "orange"]

# ... in random order
colors.sort (a, b) ->
  Math.random() > 0.5


###
HTTP server
###
server = http.createServer((request, response) ->
)

# Not important for us. We're writing WebSocket server, not HTTP server
server.listen webSocketsServerPort, ->
  console.log (new Date()) + " Server is listening on port " + webSocketsServerPort


###
WebSocket server
###

# WebSocket server is tied to a HTTP server. WebSocket request is just
# an enhanced HTTP request. For more info http://tools.ietf.org/html/rfc6455#page-6





wsServer = new webSocketServer(httpServer: server)

# This callback function is called every time someone
# tries to connect to the WebSocket server
wsServer.on "request", (request) ->
  console.log (new Date()) + " Connection from origin " + request.origin + "."
  
  # accept connection - you should check 'request.origin' to make sure that
  # client is connecting from your website
  # (http://en.wikipedia.org/wiki/Same_origin_policy)
  connection = request.accept(null, request.origin)
  
  # we need to know client index to remove them on 'close' event
  index = clients.push(connection) - 1
  MAC = false
  userColor = false
  console.log (new Date()) + " Connection accepted."
  
  # send back chat history
  if history.length > 0
    connection.sendUTF JSON.stringify(
      type: "history"
      data: history
    )
  
  # user sent some message
  connection.on "message", (message) ->
    if message.type is "utf8" # accept only text
      if MAC is false # first message sent by user is their name
      	try
      		msgParts = message.utf8Data.split(":")
      	catch error
      		connection.sendUTF "not connected"
      		return
      	if msgParts[0] == "connect"
      		#need to add validation on this part to make sure the mac is really a mac address
      		MAC = msgParts[1]
      		clientDict[MAC] = connection
      		connection.sendUTF "connected"
      		console.log "connected"
      		
      	else
      		connection.sendUTF "not connected"
      		return
  
        
        # get random color and send it back to the user
        userColor = colors.shift()
        connection.sendUTF JSON.stringify(
          type: "color"
          data: userColor
        )
        console.log (new Date()) + " User is known as: " + MAC + " with " + userColor + " color."
      else # log and broadcast the message
      
      	if message.utf8Data == "ping"
      		connecction.sendUTF "pong"
      		return
      	
        console.log (new Date()) + " Received Message from " + MAC + ": " + message.utf8Data
        
        # we want to keep history of all sent messages
        obj =
          time: (new Date()).getTime()
          text: htmlEntities(message.utf8Data)
          author: MAC
          color: userColor

        history.push obj
        history = history.slice(-100)
        
        # broadcast message to all connected clients
        json = JSON.stringify(
          type: "message"
          data: obj
        )
        i = 0

		for client of clientDict
			tmp = clientDict[client]
			tmp.sendUTF "hi"
			
	
        

  
  # user disconnected
  connection.on "close", (connection) ->
    if MAC isnt false and userColor isnt false
      console.log (new Date()) + " Peer " + connection.remoteAddress + " disconnected."
     
      # remove user from the list of connected clients
      clients.splice index, 1
      delete clientDict[MAC]
      
      MAC = false 
     
      
      # push back user's color to be reused by another user
      colors.push userColor
      
htmlEntities = (str) ->
  String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace /"/g, "&quot;"
"use strict"

