// Generated by CoffeeScript 1.6.2
/*
Global variables
*/


/*
Helper function for escaping input strings
*/


(function() {
  var async, clientDict, clients, colors, create, history, http, inspect, parseString, responceDict, respond, restify, sendData, sendResp, server, webSocketServer, webSocketsServerPort, wsServer;

  inspect = require("eyes").inspector({
    maxLength: false
  });

  async = require("async");

  parseString = require("xml2js").parseString;

  process.title = "node-chat";

  webSocketsServerPort = 1337;

  webSocketServer = require("websocket").server;

  http = require("http");

  history = [];

  clients = [];

  clientDict = new Object;

  responceDict = new Object;

  colors = ["red", "green", "blue", "magenta", "purple", "plum", "orange"];

  colors.sort(function(a, b) {
    return Math.random() > 0.5;
  });

  /*
  HTTP server
  */


  server = http.createServer(function(request, response) {});

  server.listen(webSocketsServerPort, function() {
    return console.log((new Date()) + " Server is listening on port " + webSocketsServerPort);
  });

  /*
  WebSocket server
  */


  wsServer = new webSocketServer({
    httpServer: server,
    keepalive: false,
    keepaliveInterval: 60000,
    dropConnectionOnKeepaliveTimeout: false,
    keepaliveGracePeriod: 2000
  });

  wsServer.on("request", function(request) {
    var MAC, connection, hbID, heartbeat, userColor;

    console.log((new Date()) + " Connection from origin " + request.origin + ".");
    connection = request.accept(null, request.origin);
    MAC = false;
    userColor = false;
    console.log((new Date()) + " Connection accepted.");
    hbID = false;
    connection.on("message", function(message) {
      var error, msgParts;

      if (message.type === "utf8") {
        if (MAC === false) {
          try {
            msgParts = message.utf8Data.split(":");
          } catch (_error) {
            error = _error;
            connection.sendUTF("not_connected");
            return;
          }
          if (msgParts[0] === "connect") {
            MAC = msgParts[1];
            clientDict[MAC] = connection;
            responceDict[MAC] = false;
            connection.sendUTF("connected");
            return console.log("connected");
          } else {
            connection.sendUTF("not_connected");
          }
        } else {
          if (message.utf8Data === "ping") {
            connection.sendUTF("pong");
            return;
          }
          console.log("hi");
          responceDict[MAC] = message.utf8Data;
          console.log(responceDict[MAC]);
          if (hbID === false) {
            return hbID = setInterval(heartbeat, 60000);
          }
        }
      }
    });
    heartbeat = function() {
      console.log("running heart beat from " + MAC);
      return connection.sendUTF("ping");
    };
    return connection.on("close", function(connection) {
      console.log("client is exiting");
      if (MAC !== false) {
        delete clientDict[MAC];
        MAC = false;
        return clearInterval(hbID);
      }
    });
  });

  /*
  Restful API for setting channels
  */


  sendData = function(xml) {
    var id, string;

    id = "";
    string = "";
    parseString(xml, function(err, result) {
      var command, key, key2, name, value;

      id = result.sci_request.send_message[0].targets[0].device[0].$.id;
      id = id.replace("00000000-00000000-", "");
      id = id.replace("FF-FF", "");
      for (key in result.sci_request.send_message[0].rci_request[0].do_command[0].data[0]) {
        command = key;
        inspect(key);
        for (key2 in result.sci_request.send_message[0].rci_request[0].do_command[0].data[0][key][0].$) {
          inspect(key2);
          if (key2 === "name") {
            name = result.sci_request.send_message[0].rci_request[0].do_command[0].data[0][key][0].$[key2];
          }
          if (key2 === "value") {
            value = result.sci_request.send_message[0].rci_request[0].do_command[0].data[0][key][0].$[key2];
          }
        }
        string += "<" + command + " name='" + name + "' value='" + value + "'/>";
        console.log(string);
      }
      responceDict[id] = false;
      console.log("I'm here");
      return clientDict[id].sendUTF(string);
    });
    console.log(id);
    return id;
  };

  respond = function(req, res, next) {
    var key, keys;

    keys = [];
    for (key in clientDict) {
      console.log(key);
    }
    return res.send("hello " + clientDict[req.params.name]);
  };

  restify = require("restify");

  server = restify.createServer();

  server.use(restify.bodyParser({
    mapParams: false
  }));

  server.post("/API/", create = function(req, res, next) {
    var count, error, newId, xml;

    newId = "";
    xml = req.body;
    console.log("here is the xml");
    inspect(xml);
    try {
      console.log("trying");
      newId = sendData(xml);
      console.log("here is the id");
      console.log(newId);
    } catch (_error) {
      error = _error;
      res.send(201, "Gateway: " + newId + " Not Connected or Bad XML");
      next();
    }
    count = 0;
    return async.whilst((function() {
      return responceDict[newId] === false && count < 40;
    }), (function(callback) {
      count += 1;
      return setTimeout(callback, 500);
    }), function(err) {
      var msg;

      if (responceDict[newId] === false) {
        msg = "timed out waiting for response from the gateway";
        return sendResp(msg, res, next);
      } else {
        return sendResp(responceDict[newId], res, next);
      }
    });
  });

  sendResp = function(respon, res, next) {
    res.header('Content-Type', 'text/plain');
    res.send(201, respon);
    return next();
  };

  clients = function(req, res, next) {
    var data, key;

    data = "";
    for (key in clientDict) {
      data += ", " + key;
    }
    res.header('Content-Type', 'text/plain');
    res.send(data);
    return next();
  };

  server.get("/clients", clients);

  server.head("/hello/:name", respond);

  server.listen(8080, function() {
    return console.log("%s listening at %s", server.name, server.url);
  });

}).call(this);
